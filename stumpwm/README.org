#+TITLE: StumpWM configuration
#+PROPERTY: header-args:lisp :tangle .config/stumpwm/config :mkdirp yes

* Installation
#+BEGIN_SRC shell :tangle .scripts/stumpwm/init-ubuntu.sh :shebang #!/bin/sh :mkdirp yes
  sudo apt install stumpwm
#+END_SRC

* StumpWM configuration
#+BEGIN_SRC lisp
  (in-package :stumpwm)
#+END_SRC

** Set environment variables
#+BEGIN_SRC lisp
  (setf (getenv "GDK_CORE_DEVICE_EVENTS") "1")
#+END_SRC

** Turning off startup message
#+BEGIN_SRC lisp
  (setq *startup-message* nil)  
#+END_SRC

** Prefix key
#+BEGIN_SRC lisp
  (set-prefix-key (kbd "s-t"))
#+END_SRC

** Keybind
#+BEGIN_SRC lisp
  (define-key *top-map* (kbd "s-;") "colon")
  (define-key *top-map* (kbd "s-:") "eval")
  (define-key *top-map* (kbd "s-R") "restart-hard")
#+END_SRC

* Modules
*** Battery indicator
**** Setup
#+BEGIN_SRC lisp
    (load-module "battery-portable")
#+END_SRC

*** Network manager
**** Setup
#+BEGIN_SRC lisp
    (load-module "stump-nm")
#+END_SRC

**** Keybind
This maps <prefix> C-w to list the wireless networks.

#+BEGIN_SRC lisp
  (define-key *root-map* (kbd "C-w") "nm-list-wireless-networks")
#+END_SRC

*** Global windows
Allow to switch to any window regardless of their groups.

**** Setup
#+BEGIN_SRC lisp
    (load-module "globalwindows")
#+END_SRC

**** Keybind
#+BEGIN_SRC lisp
  (define-key *top-map* (kbd "s-w") "global-pull-windowlist")
  (define-key *top-map* (kbd "s-W") "global-windowlist")
#+END_SRC

* Custom functions
** Window utils
*** Get window class
This will get a window class name without raising an error for the NIL window.
#+BEGIN_SRC lisp
  (defcommand window-class-safe (window) (:window)
              (if (not window)
                  ""
                  (window-class window)))
#+END_SRC

*** Convert a direction object to a string
#+BEGIN_SRC lisp
  (defcommand direction-to-string(direction) ((:direction "Direction: "))
              (string-downcase (subseq (write-to-string direction) 1)))
#+END_SRC

*** Pull hidden window be direction
This pulls the next or previous window according to a string parameter.
#+BEGIN_SRC lisp
  (defcommand pull-hidden-direction (direction) (:string)
              (if (string= direction "next")
                  (pull-hidden-next)
                  (pull-hidden-previous)))
#+END_SRC
  
*** Pull hidden window included in classes
Pulls the next/previous hidden window with a class in classes list.
#+BEGIN_SRC lisp
  (defcommand pull-hidden-include-classes-aux (direction current-window classes max-length) (:string :window :list :number)
              (pull-hidden-direction direction)
              (let ((next-win (current-window)))
                (if (and (> max-length 0) (not (equal current-window next-win)) (null (member (window-class-safe next-win) classes :test #'string=)))
                    (pull-hidden-include-classes-aux direction current-window classes (- max-length 1)))))
  
  (defcommand pull-hidden-include-classes (direction classes) (:string :list)
              (pull-hidden-include-classes-aux direction (current-window) classes 200))
  #+END_SRC

*** Pull hidden window excluded from classes
Pulls the next/previous hidden window with a class not in classes list.
#+BEGIN_SRC lisp
  (defcommand pull-hidden-exclude-classes-aux (direction current-window classes max-length) (:string :window :list :number)
              (pull-hidden-direction direction)
              (let ((next-win (current-window)))
                (if (and (> max-length 0) (not (equal current-window next-win)) (and (not (null next-win)) (not (null (member (window-class-safe next-win) classes :test #'string=)))))
                    (pull-hidden-exclude-classes-aux direction current-window classes (- max-length 1)))))
  
  (defcommand pull-hidden-exclude-classes (direction classes) (:string :list)
              (pull-hidden-exclude-classes-aux direction (current-window) classes 200))
 #+END_SRC
 
*** Hidden window matches properties predicate
#+BEGIN_SRC lisp
  (defun hidden-window-matches-properties-p (window &key class instance type role title)
    "Returns T if window matches all the given properties"
    (and
     (not (window-visible-p window))
     (if class (string-match (window-class window) class) t)
     (if instance (string-match (window-res window) instance) t)
     (if type (string-match (window-type window) type) t)
     (if role (string-match (window-role window) role) t)
     (if title (string-match (window-title window) title) t) t))
  #+END_SRC
  
*** Find hidden window matches properties
#+BEGIN_SRC lisp
  (defun find-hidden-matching-windows (props all-groups all-screens)
    "Returns list of windows matching @var{props} (see run-or-raise
  documentation for details). @var{all-groups} will find windows on all
  groups. Same for @{all-screens}. Result is sorted by group and window
  number, with group being more significant (think radix sort)."
    (let* ((screens (if all-screens
                        ,*screen-list*
                        (list (current-screen))))
           (winlist (if all-groups
                        (mapcan (lambda (s) (screen-windows s)) screens)
                        (group-windows (current-group))))
           (matches (remove-if-not (lambda (w)
                                     (apply 'hidden-window-matches-properties-p w props))
                                   winlist)))
      (stable-sort (sort matches #'< :key #'window-number)
                   #'< :key (lambda (w) (group-number (window-group w))))))
#+END_SRC
  
*** Run of pull hidden window
#+BEGIN_SRC lisp
  (defun run-or-pull-hidden (cmd props &optional (all-groups *run-or-raise-all-groups*)
                                         (all-screens *run-or-raise-all-screens*))
    "Similar to run-or-raise, but move the matching window to the
  current frame instead of switching to the window."
    (let* ((matches (find-hidden-matching-windows props t t))
           ;; other-matches is for cycling through matches
           (other-matches (member (current-window) matches))
           (win (if (> (length other-matches) 1)
                    (second other-matches)
                    (first matches))))
      (if win
          (progn
            (move-window-to-group win (current-group))
            (pull-window win))
          (run-shell-command cmd))))
#+END_SRC
  
*** Move focus to direction
If moving focus according to a direction (left, right, up, down).

It has a special behaviour if the focused window is an Emacs frame.
In this case, I move inside of Emacs frames instead of StumpWM frames if Emacs has frames open in that direction.
#+BEGIN_SRC lisp
  (defcommand go-direction(direction) ((:direction "Direction: "))
                  (let ((w (current-window)))
                    (if (string= (window-class-safe w) "Emacs")
                        (if (string= "
  " (run-shell-command (concatenate 'string "emacsclient -e '(windmove-" (direction-to-string direction) ")'") t))
                            (move-focus direction))
                        (move-focus direction))))
#+END_SRC

* Behaviours
** Mouse focus policy
#+BEGIN_SRC lisp
  (setf *mouse-focus-policy* :click)
#+END_SRC

* Theme
** Colors
#+BEGIN_SRC lisp
  (setf vl/fg-color "#d8dee9"
        vl/fg-alt-color "#93979f"
        vl/bg-color "#2e3440"
        vl/bg-alt-color "#242832"
        vl/focus-color "#a3be8c"
        *colors* '("#2e3440" "#bf616a" "#a3be8c" "#eBcb8b" "#5e81ac" "#b48ead" "#88c0d0" "#d8dee9"))
  
  (set-fg-color vl/fg-color)
  (set-bg-color vl/bg-alt-color)
  (set-border-color vl/bg-color)
  (set-win-bg-color vl/bg-color)
  (set-focus-color vl/focus-color)
  (set-unfocus-color vl/bg-color)

  (update-color-map (current-screen))
#+END_SRC

** Fonts
#+BEGIN_SRC lisp
  ;; TODO
#+END_SRC

** Mouse look
#+BEGIN_SRC lisp
  (run-shell-command "xsetroot -cursor_name left_ptr")
#+END_SRC

* Modeline
** Theme
#+BEGIN_SRC lisp
  (setf *mode-line-background-color* vl/bg-color
        *mode-line-foreground-color* vl/fg-alt-color
        *mode-line-border-color* vl/bg-color
        *screen-mode-line-format* (list "%d | %g ^> %B")
        *time-modeline-string* "%e %b %Y %k:%M")
#+END_SRC

** Keybind
#+BEGIN_SRC lisp
  (define-key *top-map* (kbd "s-m") "mode-line")
#+END_SRC

* Window management
** Theme
#+BEGIN_SRC lisp
  (setf *message-window-gravity* :top
        *input-window-gravity* :top
        *input-completion-type* :fuzzy
        *window-border-style* :thin
        *message-window-padding* 50
        *message-window-width* 100
        *maxsize-border-width* 2
        *normal-border-width* 2
        *transient-border-width* 2
        stumpwm::*float-window-border* 2
        stumpwm::*float-window-title-height* 20
        *window-format* "%m[%n] %c: %t ")

  (set-msg-border-width 0)
#+END_SRC

** Resize frame
*** Resize increment
#+BEGIN_SRC lisp
  (setf *resize-increment* 50)
#+END_SRC

*** Keybind
#+BEGIN_SRC lisp
  (define-key *top-map* (kbd "s-f") "fullscreen")
  
  (define-key *top-map* (kbd "C-s-l") "resize 50 0")
  (define-key *top-map* (kbd "C-s-h") "resize -50 0")
  (define-key *top-map* (kbd "C-s-k") "resize 0 -50")
  (define-key *top-map* (kbd "C-s-j") "resize 0 50")
#+END_SRC

** Create and deleting frames and windows
*** Utils
#+BEGIN_SRC lisp
  (defcommand emacs-run-or-pull-hidden (command) (:string)
              (run-or-pull-hidden "emacsclient -c" '(:class "Emacs"))
              (run-shell-command (concatenate 'string "emacsclient -e \"" command "\"")))
  
  (defcommand emacs-interactive-aux (command) (:string)
              (run-or-pull-hidden "emacsclient -c" '(:class "Emacs"))
              (run-shell-command (concatenate 'string "emacsclient -e \"(call-interactively #'" command ")\"")))
  
  (defcommand emacs-interactive (command) (:string)
              (let ((w (current-window)))
                (if (string= (window-class-safe w) "Emacs")
                    (run-shell-command (concatenate 'string "emacsclient -e \"(call-interactively #'" command ")\""))
                    (emacs-interactive-aux command))))

  (defcommand utils/delete-window () ()
              (let ((w (current-window)))
                (if (string= (window-class-safe w) "Emacs")
                    (emacs-interactive "kill-buffer")
                    (delete-window))))
#+END_SRC

*** Keybind
#+BEGIN_SRC lisp
  (define-key *top-map* (kbd "s-s") "hsplit")
  (define-key *top-map* (kbd "s-S") "vsplit")
  (define-key *top-map* (kbd "s-Q") "remove-split")
  (define-key *top-map* (kbd "s-q") "delete")
  ;; (define-key *top-map* (kbd "C-s-q") "utils/delete-window")
#+END_SRC

** Select frames
*** Keybind
#+BEGIN_SRC lisp
  (define-key *top-map* (kbd "s-h") "go-direction left")
  (define-key *top-map* (kbd "s-j") "go-direction down")
  (define-key *top-map* (kbd "s-k") "go-direction up")
  (define-key *top-map* (kbd "s-l") "go-direction right")
#+END_SRC

** Move window
*** Keybind
#+BEGIN_SRC lisp
  (define-key *top-map* (kbd "s-H") "move-window left")
  (define-key *top-map* (kbd "s-J") "move-window down")
  (define-key *top-map* (kbd "s-K") "move-window up")
  (define-key *top-map* (kbd "s-L") "move-window right")
#+END_SRC

** Exchange window
*** Keybind
#+BEGIN_SRC lisp
  (define-key *top-map* (kbd "M-s-h") "exchange-direction left")
  (define-key *top-map* (kbd "M-s-j") "exchange-direction down")
  (define-key *top-map* (kbd "M-s-k") "exchange-direction up")
  (define-key *top-map* (kbd "M-s-l") "exchange-direction right")
#+END_SRC

** Switch between browser windows
*** Utils
#+BEGIN_SRC lisp
    (defcommand pull-hidden-browser (direction) (:string)
                (let ((current-win (current-window)))
                  (pull-hidden-include-classes direction '("qutebrowser"))
                  (if (and (not (string= (window-class-safe current-win) "qutebrowser")) (equal current-win (current-window)))
                      (run-shell-command "qutebrowser"))))
#+END_SRC
    
*** Keybind
#+BEGIN_SRC lisp
    (define-key *top-map* (kbd "s-i") "pull-hidden-browser next")
    (define-key *top-map* (kbd "s-I") "pull-hidden-browser previous")
    (define-key *top-map* (kbd "C-s-i") "exec qutebrowser")
#+END_SRC
  
** Switch between Emacs window/buffer
*** Utils
#+BEGIN_SRC lisp
  (defcommand emacs-change-buffer (direction) (:string)
              (let ((w (current-window)))
                (if (string= (window-class-safe w) "Emacs")
                    (run-shell-command (concatenate 'string "emacsclient -e '(nswbuff-switch-to-" direction "-buffer)'"))
                    (emacs-run-or-pull-hidden "()"))))
#+END_SRC

*** Keybind
#+BEGIN_SRC lisp
  (define-key *top-map* (kbd "s-RET") "emacs-interactive vterm")
  
  (define-key *top-map* (kbd "s-e") "emacs-change-buffer next")
  (define-key *top-map* (kbd "s-E") "emacs-change-buffer previous")
  
  (define-key *top-map* (kbd "s-a") "emacs-interactive app-launcher-run-app")
  
  (define-key *top-map* (kbd "s-.") "emacs-interactive find-file")
  
  (define-key *top-map* (kbd "s-b") "emacs-interactive consult-buffer")
  (define-key *top-map* (kbd "s-B") "emacs-interactive ibuffer")
  
  (define-key *top-map* (kbd "s-p") "emacs-interactive treemacs")
#+END_SRC

** Switch between other windows
*** Utils
#+BEGIN_SRC lisp
  (defcommand pull-hidden-relevant-window (direction) (:string)
              (pull-hidden-exclude-classes direction '("qutebrowser" "Emacs" "Gnome-flashback")))
#+END_SRC

*** Keybind
#+BEGIN_SRC lisp
  (define-key *top-map* (kbd "s-TAB") "pull-hidden-relevant-window next")
  (define-key *top-map* (kbd "s-ISO_Left_Tab") "pull-hidden-relevant-window previous")
#+END_SRC

* Group management
** Select groups
*** Keybind
#+BEGIN_SRC lisp
  (define-key *top-map* (kbd "s-]") "gnext")
  (define-key *top-map* (kbd "s-[") "gprev")

  (define-key *top-map* (kbd "s-1") "gselect 1")
  (define-key *top-map* (kbd "s-2") "gselect 2")
  (define-key *top-map* (kbd "s-3") "gselect 3")
  (define-key *top-map* (kbd "s-4") "gselect 4")
  (define-key *top-map* (kbd "s-5") "gselect 5")
  (define-key *top-map* (kbd "s-6") "gselect 6")
  (define-key *top-map* (kbd "s-7") "gselect 7")
  (define-key *top-map* (kbd "s-8") "gselect 8")
  (define-key *top-map* (kbd "s-9") "gselect 9")
  (define-key *top-map* (kbd "s-0") "gselect 0")
#+END_SRC

** Move window to groups
*** Keybind
#+BEGIN_SRC lisp
  (define-key *top-map* (kbd "s-!") "gmove 1")
  (define-key *top-map* (kbd "s-@") "gmove 2")
  (define-key *top-map* (kbd "s-#") "gmove 3")
  (define-key *top-map* (kbd "s-$") "gmove 4")
  (define-key *top-map* (kbd "s-%") "gmove 5")
  (define-key *top-map* (kbd "s-^") "gmove 6")
  (define-key *top-map* (kbd "s-&") "gmove 7")
  (define-key *top-map* (kbd "s-*") "gmove 8")
  (define-key *top-map* (kbd "s-(") "gmove 9")
  (define-key *top-map* (kbd "s-)") "gmove 0")
#+END_SRC

* Startup commands
#+BEGIN_SRC lisp
  (run-shell-command "setxkbmap -option 'caps:ctrl_modifier' && xcape -e 'Caps_Lock=Escape'")
  
  (run-shell-command "gsettings set org.gnome.gnome-flashback.desktop.icons show-home false")
  (run-shell-command "gsettings set org.gnome.gnome-flashback.desktop.icons show-trash false")
  
  (run-shell-command "pkill emacs")
  (run-shell-command "emacs --daemon")
#+END_SRC

