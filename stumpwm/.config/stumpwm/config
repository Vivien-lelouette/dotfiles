(in-package :stumpwm)

(setf (getenv "GDK_CORE_DEVICE_EVENTS") "1")

(setq *startup-message* nil)

(set-prefix-key (kbd "s-t"))

(define-key *top-map* (kbd "s-;") "colon")
(define-key *top-map* (kbd "s-:") "eval")
(define-key *top-map* (kbd "s-R") "restart-hard")

(load-module "battery-portable")

(load-module "stump-nm")

(define-key *root-map* (kbd "C-w") "nm-list-wireless-networks")

(load-module "globalwindows")

(define-key *top-map* (kbd "s-w") "global-pull-windowlist")
(define-key *top-map* (kbd "s-W") "global-windowlist")

(defcommand window-class-safe (window) (:window)
            (if (not window)
                ""
                (window-class window)))

(defcommand direction-to-string(direction) ((:direction "Direction: "))
            (string-downcase (subseq (write-to-string direction) 1)))

(defcommand pull-hidden-direction (direction) (:string)
            (if (string= direction "next")
                (pull-hidden-next)
                (pull-hidden-previous)))

(defcommand pull-hidden-include-classes-aux (direction current-window classes max-length) (:string :window :list :number)
            (pull-hidden-direction direction)
            (let ((next-win (current-window)))
              (if (and (> max-length 0) (not (equal current-window next-win)) (null (member (window-class-safe next-win) classes :test #'string=)))
                  (pull-hidden-include-classes-aux direction current-window classes (- max-length 1)))))

(defcommand pull-hidden-include-classes (direction classes) (:string :list)
            (pull-hidden-include-classes-aux direction (current-window) classes 200))

(defcommand pull-hidden-exclude-classes-aux (direction current-window classes max-length) (:string :window :list :number)
            (pull-hidden-direction direction)
            (let ((next-win (current-window)))
              (if (and (> max-length 0) (not (equal current-window next-win)) (and (not (null next-win)) (not (null (member (window-class-safe next-win) classes :test #'string=)))))
                  (pull-hidden-exclude-classes-aux direction current-window classes (- max-length 1)))))

(defcommand pull-hidden-exclude-classes (direction classes) (:string :list)
            (pull-hidden-exclude-classes-aux direction (current-window) classes 200))

(defun hidden-window-matches-properties-p (window &key class instance type role title)
  "Returns T if window matches all the given properties"
  (and
   (not (window-visible-p window))
   (if class (string-match (window-class window) class) t)
   (if instance (string-match (window-res window) instance) t)
   (if type (string-match (window-type window) type) t)
   (if role (string-match (window-role window) role) t)
   (if title (string-match (window-title window) title) t) t))

(defun find-hidden-matching-windows (props all-groups all-screens)
  "Returns list of windows matching @var{props} (see run-or-raise
documentation for details). @var{all-groups} will find windows on all
groups. Same for @{all-screens}. Result is sorted by group and window
number, with group being more significant (think radix sort)."
  (let* ((screens (if all-screens
                      *screen-list*
                      (list (current-screen))))
         (winlist (if all-groups
                      (mapcan (lambda (s) (screen-windows s)) screens)
                      (group-windows (current-group))))
         (matches (remove-if-not (lambda (w)
                                   (apply 'hidden-window-matches-properties-p w props))
                                 winlist)))
    (stable-sort (sort matches #'< :key #'window-number)
                 #'< :key (lambda (w) (group-number (window-group w))))))

(defun run-or-pull-hidden (cmd props &optional (all-groups *run-or-raise-all-groups*)
                                       (all-screens *run-or-raise-all-screens*))
  "Similar to run-or-raise, but move the matching window to the
current frame instead of switching to the window."
  (let* ((matches (find-hidden-matching-windows props t t))
         ;; other-matches is for cycling through matches
         (other-matches (member (current-window) matches))
         (win (if (> (length other-matches) 1)
                  (second other-matches)
                  (first matches))))
    (if win
        (progn
          (move-window-to-group win (current-group))
          (pull-window win))
        (run-shell-command cmd))))

(defcommand go-direction(direction) ((:direction "Direction: "))
                (let ((w (current-window)))
                  (if (string= (window-class-safe w) "Emacs")
                      (if (string= "
" (run-shell-command (concatenate 'string "emacsclient -e '(windmove-" (direction-to-string direction) ")'") t))
                          (move-focus direction))
                      (move-focus direction))))

(setf *mouse-focus-policy* :click)

(setf vl/fg-color "#d8dee9"
      vl/fg-alt-color "#93979f"
      vl/bg-color "#2e3440"
      vl/bg-alt-color "#242832"
      vl/focus-color "#a3be8c"
      *colors* '("#2e3440" "#bf616a" "#a3be8c" "#eBcb8b" "#5e81ac" "#b48ead" "#88c0d0" "#d8dee9"))

(set-fg-color vl/fg-color)
(set-bg-color vl/bg-alt-color)
(set-border-color vl/bg-color)
(set-win-bg-color vl/bg-color)
(set-focus-color vl/focus-color)
(set-unfocus-color vl/bg-color)

(update-color-map (current-screen))

;; TODO

(run-shell-command "xsetroot -cursor_name left_ptr")

(setf *mode-line-background-color* vl/bg-color
      *mode-line-foreground-color* vl/fg-alt-color
      *mode-line-border-color* vl/bg-color
      *screen-mode-line-format* (list "%d | %g ^> %B")
      *time-modeline-string* "%e %b %Y %k:%M")

(define-key *top-map* (kbd "s-m") "mode-line")

(setf *message-window-gravity* :top
      *input-window-gravity* :top
      *input-completion-type* :fuzzy
      *window-border-style* :thin
      *message-window-padding* 50
      *message-window-width* 100
      *maxsize-border-width* 2
      *normal-border-width* 2
      *transient-border-width* 2
      stumpwm::*float-window-border* 2
      stumpwm::*float-window-title-height* 20
      *window-format* "%m[%n] %c: %t ")

(set-msg-border-width 0)

(setf *resize-increment* 50)

(define-key *top-map* (kbd "s-f") "fullscreen")

(define-key *top-map* (kbd "C-s-l") "resize 50 0")
(define-key *top-map* (kbd "C-s-h") "resize -50 0")
(define-key *top-map* (kbd "C-s-k") "resize 0 -50")
(define-key *top-map* (kbd "C-s-j") "resize 0 50")

(defcommand emacs-run-or-pull-hidden (command) (:string)
            (run-or-pull-hidden "emacsclient -c" '(:class "Emacs"))
            (run-shell-command (concatenate 'string "emacsclient -e \"" command "\"")))

(defcommand emacs-interactive-aux (command) (:string)
            (run-or-pull-hidden "emacsclient -c" '(:class "Emacs"))
            (run-shell-command (concatenate 'string "emacsclient -e \"(call-interactively #'" command ")\"")))

(defcommand emacs-interactive (command) (:string)
            (let ((w (current-window)))
              (if (string= (window-class-safe w) "Emacs")
                  (run-shell-command (concatenate 'string "emacsclient -e \"(call-interactively #'" command ")\""))
                  (emacs-interactive-aux command))))

(defcommand utils/delete-window () ()
            (let ((w (current-window)))
              (if (string= (window-class-safe w) "Emacs")
                  (emacs-interactive "kill-buffer")
                  (delete-window))))

(define-key *top-map* (kbd "s-s") "hsplit")
(define-key *top-map* (kbd "s-S") "vsplit")
(define-key *top-map* (kbd "s-Q") "remove-split")
(define-key *top-map* (kbd "s-q") "delete")
;; (define-key *top-map* (kbd "C-s-q") "utils/delete-window")

(define-key *top-map* (kbd "s-h") "go-direction left")
(define-key *top-map* (kbd "s-j") "go-direction down")
(define-key *top-map* (kbd "s-k") "go-direction up")
(define-key *top-map* (kbd "s-l") "go-direction right")

(define-key *top-map* (kbd "s-H") "move-window left")
(define-key *top-map* (kbd "s-J") "move-window down")
(define-key *top-map* (kbd "s-K") "move-window up")
(define-key *top-map* (kbd "s-L") "move-window right")

(define-key *top-map* (kbd "M-s-h") "exchange-direction left")
(define-key *top-map* (kbd "M-s-j") "exchange-direction down")
(define-key *top-map* (kbd "M-s-k") "exchange-direction up")
(define-key *top-map* (kbd "M-s-l") "exchange-direction right")

(defcommand pull-hidden-browser (direction) (:string)
            (let ((current-win (current-window)))
              (pull-hidden-include-classes direction '("qutebrowser"))
              (if (and (not (string= (window-class-safe current-win) "qutebrowser")) (equal current-win (current-window)))
                  (run-shell-command "qutebrowser"))))

(define-key *top-map* (kbd "s-i") "pull-hidden-browser next")
(define-key *top-map* (kbd "s-I") "pull-hidden-browser previous")
(define-key *top-map* (kbd "C-s-i") "exec qutebrowser")

(defcommand emacs-change-buffer (direction) (:string)
            (let ((w (current-window)))
              (if (string= (window-class-safe w) "Emacs")
                  (run-shell-command (concatenate 'string "emacsclient -e '(nswbuff-switch-to-" direction "-buffer)'"))
                  (emacs-run-or-pull-hidden "()"))))

(define-key *top-map* (kbd "s-RET") "emacs-interactive vterm")

(define-key *top-map* (kbd "s-e") "emacs-change-buffer next")
(define-key *top-map* (kbd "s-E") "emacs-change-buffer previous")

(define-key *top-map* (kbd "s-a") "emacs-interactive app-launcher-run-app")

(define-key *top-map* (kbd "s-.") "emacs-interactive find-file")

(define-key *top-map* (kbd "s-b") "emacs-interactive consult-buffer")
(define-key *top-map* (kbd "s-B") "emacs-interactive ibuffer")

(define-key *top-map* (kbd "s-p") "emacs-interactive treemacs")

(defcommand pull-hidden-relevant-window (direction) (:string)
            (pull-hidden-exclude-classes direction '("qutebrowser" "Emacs" "Gnome-flashback")))

(define-key *top-map* (kbd "s-TAB") "pull-hidden-relevant-window next")
(define-key *top-map* (kbd "s-ISO_Left_Tab") "pull-hidden-relevant-window previous")

(define-key *top-map* (kbd "s-]") "gnext")
(define-key *top-map* (kbd "s-[") "gprev")

(define-key *top-map* (kbd "s-1") "gselect 1")
(define-key *top-map* (kbd "s-2") "gselect 2")
(define-key *top-map* (kbd "s-3") "gselect 3")
(define-key *top-map* (kbd "s-4") "gselect 4")
(define-key *top-map* (kbd "s-5") "gselect 5")
(define-key *top-map* (kbd "s-6") "gselect 6")
(define-key *top-map* (kbd "s-7") "gselect 7")
(define-key *top-map* (kbd "s-8") "gselect 8")
(define-key *top-map* (kbd "s-9") "gselect 9")
(define-key *top-map* (kbd "s-0") "gselect 0")

(define-key *top-map* (kbd "s-!") "gmove 1")
(define-key *top-map* (kbd "s-@") "gmove 2")
(define-key *top-map* (kbd "s-#") "gmove 3")
(define-key *top-map* (kbd "s-$") "gmove 4")
(define-key *top-map* (kbd "s-%") "gmove 5")
(define-key *top-map* (kbd "s-^") "gmove 6")
(define-key *top-map* (kbd "s-&") "gmove 7")
(define-key *top-map* (kbd "s-*") "gmove 8")
(define-key *top-map* (kbd "s-(") "gmove 9")
(define-key *top-map* (kbd "s-)") "gmove 0")

(run-shell-command "setxkbmap -option 'caps:ctrl_modifier' && xcape -e 'Caps_Lock=Escape'")

(run-shell-command "gsettings set org.gnome.gnome-flashback.desktop.icons show-home false")
(run-shell-command "gsettings set org.gnome.gnome-flashback.desktop.icons show-trash false")

(run-shell-command "pkill emacs")
(run-shell-command "emacs --daemon")
